## 단위테스트

## 0. 결론

- 테스트 코드는 실제 코드를 강화 시킨다.
  - 유연성 
  - 유지보수성
  - 재사용성
- 깨끗하게 관리하자
  - 표현력을 높이기 위해 DSL을 만들자
  - 하나의 함수 마다 하나의 개념만 테스트하자

- 테스트 코드는 시간과 안전의 TradeOff

  - 사고가 생기면 나중에 시간은 배로든다.

  - 복잡한 코드일 수록 TC가 필요하다.

    

## 1. 유닛 테스트

- 작성, 수정된 코드가 제대로 도는지 보장하는 방법 

  - 코드 변경을 안심하고 할 수 있다. 
  - 실제 코드와 함께 관리

  

- TDD 법칙세가지

  - 실패하는 단위 테스트를 작성할때까지 실제 코드를 작성하지 않는다.
    - 테스트케이스를 먼저 작성한다.
  - 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위테스트를 작성한다.
    - 컴파일은 성공한다고 가정?
    - 프레임워크 기반 개발
  - 현재 실패하는 테스트를 통과할 정도로만 실제코드를 작성한다.
    - 개발 시간

  

- 테스트 코드와 실제코드가 함께 나온다.

- 실제 코드를 전부 테스트 할 수 있다.

- 방대한 테스트 코드는 심각한 관리 문제를 유발한다.



## 2. 깨끗한 테스트 코드 

- 자동화된 테스트코드

- 지저분한 테스트 코드는 안하느니만 못하다.
- 실제 코드를 짜는 시간보다 테스트코드 추가에 오랜 시간이 걸린다.
- 결국엔 테스트코드 폐기 > 불안정한 시스템 > 결함 > 망함
- **테스트코드는 실제 코드 못지 않게 중요하다.**



#### 가독성

- 최소한의 표현으로 많은걸 나타내자
  - 중복을 피해라
  - 쓸데 없는걸 하지마라
  - 160페이지 
- 도메인 특화 언어로 테스트코드 구현 
  - 테스트 코드를 위해 API를 구현하자
  - 유틸리티 활용
  - 라이브러리 활용!
- BUILD OPERATE CHECK pattern

```
Swift

Given, When, Then으로 섹션을 나누어 작성하는 습관을 기르자

Given - 입력 값을 제공
When - 입력 값을 사용해 테스트의 대상이 되는 메소드를 실행
Then - 결과 값을 증명 (기대값과 비교)
```



#### 효율적일 필요가 없다.

- 실제 환경이 아니라 테스트 환경에서 돌아가기 때문

```java
//bad
public void turnOnCoolerAndBlowerIfTooHot() throws Exception{
	asserTrue(hw.headerState());
    asserTrue(hw.blowerState());
    asserTrue(hw.coolerState());
    asserTrue(hw.tempAlarm());
}

//good
@TEST
public void turnOnCoolerAndBlowerIfTooHot() throws Exception{
    tooHot()
    assertEquals("hBCHl", hw.getState())
}
public String getstate(){
    String state = "";
    ```
    state += header? "H":"h"
        ..
        .
        .
        .
    return state
}



    
```

- 임베디드여서 운영 환경이 제한적이더라도 테스트 환경은 그렇지 않다.



#### 테스트당 Assert하나

- 이해하기 쉽고 빠르다



- 다른 테스트는 따로 테스트한다.

  - XML로 반환된다.

  - 어떤 문자를 포함한다.

    

- 중복코드가 많아진다.

  - Template Method 패턴

    - Given과 when을 부모클래스에 두고 then을 자식 클래스에 둔다.

    - @Before에 given과 when을 두고 @Test에 then을 둔다.

      

- 테스트 코드 취향이다  
  - 최대한 Assert문을 줄인다.



#### 하나의 테스트 함수 하나의 개념

- 잡다한 개념을 몰아 넣지 말아라

```java
//bad
public void testAddMonth(){
    //given
    test1 = 인스턴스

    //when
    test2 = test1 + 조작
    test3 = test1 + 조작2
        
     //then
     test2 검증
     test3 검증
}

//good
public void test5월31에한달을더하면6월30일이되야지(){
    //given
    5월31일 = 인스턴스
    //when
    d2 = 5월31 + 조작
	//then
    d2 검증
}

public void test5월31에두달을더하면7월31일이되야지(){
    
}

public void test6월30에한달을더하면7월30일이되야지(){
    
}
    
    
```

- 장황한 테스트 코드 속에 일반적인 규칙이 보인다.
- 더 필요한 테스트 케이스를 더 찾을 수 있겠다.
  - 2월 28일 ? 윤년?

#### 그래서

- 가장 좋은건 개념 하나당 assert문 수를 최소로 줄여라
- 테스트 함수 하나당 하나의 개념만 해라



### 3. F.I.R.S.T규칙

- **F**ast - 테스팅은 빠르게 동작해야 한다.

  - 자주돌리기 때문에

  

- **I**ndependent / **I**solated - 독립적이어야 한다.

  - 테스트간의 의존성은 없어야한다. 
  - 비효율적이어도 좋다.
  - 나중에 원인 진단이 어렵다.

  

- **R**epeatable - 동일한 인풋의 테스팅의 결과는 항상 동일해야 한다.

  - 순수 함수처럼 짜라

  -  실행환경에 의존하지 않아야한다.

    - unix에서는 돌아가는데 window에서 안돌아간다?!

  - 여러 환경에서 코드가 돌아가기 때문에  

    

- **S**elf-Validating - 테스트는 완벽히 자동화되어야 한다. 그 결과 자체로 성공과 실패를 알 수 있어야 한다.

  - 테스트의 결과는 성공 아니면 실패다
    - 텍스트파일이나 다른게 결과가 될 수 없다.
  - 테스트 자동화에 필수적이다. 
  - 주관성을 배제할 수 있다.

  

- **T**imely - 이상적인 테스트 코드는 테스트할 코드를 작성하기 전 작성되어야 한다.

  - 실제코드를 먼저 작성하면 테스트코드 짜기가 어렵다. 
  - 테스트를 고려하고 짜거나
  - 테스트코드를 먼저 작성해라

